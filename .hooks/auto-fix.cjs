#!/usr/bin/env node
/**
 * Auto-Fix Script â€” Pattern-Based
 *
 * Handles dynamic IDs from persona review scripts using prefix matching.
 * IDs are generated by persona-reviews/*.cjs in the format:
 *   {persona}-{check-type}-{file-with-slashes-replaced-by-dashes}-{line}
 *
 * Three fix levels:
 *  1. CODE_MOD   â€” actual code change (safe, targeted line insertions)
 *  2. COMMENT    â€” insert FIXME comment at issue location (marks for humans)
 *  3. REPORT     â€” no file change, only log output (complex architectural issues)
 */

"use strict";

const fs = require("fs");

const issuesFile = process.argv[2];
const specificIssueId = process.argv[3];

if (!issuesFile) {
  console.error("Usage: node auto-fix.cjs <issues-file.json> [issue-id]");
  process.exit(1);
}

if (!fs.existsSync(issuesFile)) {
  console.log(`No issues file found: ${issuesFile}`);
  process.exit(0);
}

const issues = JSON.parse(fs.readFileSync(issuesFile, "utf-8"));
const toFix = specificIssueId ? issues.filter((i) => i.id === specificIssueId) : issues;

if (toFix.length === 0) {
  console.log("No issues to fix");
  process.exit(0);
}

console.log(`Auto-fixing ${toFix.length} issues...`);

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function readLines(file) {
  try {
    return fs.readFileSync(file, "utf8").split("\n");
  } catch {
    return null;
  }
}

function writeLines(file, lines) {
  fs.writeFileSync(file, lines.join("\n"), "utf8");
}

function getIndent(line) {
  return (line.match(/^(\s*)/) || ["", ""])[1];
}

/**
 * Insert a comment above a 1-based line number.
 * Idempotent: skips if the FIXME tag is already present on the preceding line.
 */
function insertCommentAbove(file, lineNum, comment) {
  const lines = readLines(file);
  if (!lines) {
    return false;
  }
  const idx = lineNum - 1;
  if (idx < 0 || idx >= lines.length) {
    return false;
  }

  // Idempotency check: skip if already present
  if (idx > 0 && lines[idx - 1].includes("FIXME(")) {
    return false;
  }

  const ws = getIndent(lines[idx]);
  lines.splice(idx, 0, `${ws}${comment}`);
  writeLines(file, lines);
  return true;
}

/**
 * Insert a comment near the top of the file (after any leading block comment).
 * Idempotent: skips if the same FIXME tag is already present.
 */
function insertCommentAtTop(file, comment) {
  const lines = readLines(file);
  if (!lines) {
    return false;
  }

  // Idempotency: skip if already present
  if (lines.some((l) => l.includes(comment.slice(0, 40)))) {
    return false;
  }

  // Find insertion point: skip leading block comment /* ... */
  let insertAt = 0;
  if (lines[0] && lines[0].trim().startsWith("/*")) {
    for (let i = 1; i < lines.length; i++) {
      if (lines[i].includes("*/")) {
        insertAt = i + 1;
        break;
      }
    }
  } else if (lines[0] && lines[0].trim().startsWith("//")) {
    let i = 0;
    while (i < lines.length && lines[i].trim().startsWith("//")) {
      i++;
    }
    insertAt = i;
  }
  lines.splice(insertAt, 0, comment, "");
  writeLines(file, lines);
  return true;
}

/**
 * Find the first line containing setInterval() and add a FIXME comment above it.
 */
function addIntervalWarning(file) {
  const lines = readLines(file);
  if (!lines) {
    return false;
  }

  for (let i = 0; i < lines.length; i++) {
    if (lines[i].includes("setInterval(")) {
      // Idempotency check
      if (i > 0 && lines[i - 1].includes("FIXME(arch-interval-leak)")) {
        return false;
      }
      const ws = getIndent(lines[i]);
      lines.splice(
        i,
        0,
        `${ws}// FIXME(arch-interval-leak): Store this interval ID and call clearInterval() in error/close handler`,
      );
      writeLines(file, lines);
      return true;
    }
  }
  return false;
}

/**
 * Fix an empty catch block by inserting a console.error call inside it.
 * The `lineNum` points to the `} catch (err) {` line.
 */
function fixEmptyCatch(file, lineNum) {
  const lines = readLines(file);
  if (!lines) {
    return false;
  }
  const idx = lineNum - 1;
  if (idx >= lines.length) {
    return false;
  }

  const catchLine = lines[idx];
  const catchMatch = catchLine.match(/\}\s*catch\s*\(\s*(\w+)\s*\)\s*\{/);
  if (!catchMatch) {
    return false;
  }

  const errVar = catchMatch[1];

  // Idempotency: check if next lines already have error handling
  const nextTwo = lines.slice(idx + 1, idx + 3).join("\n");
  if (/console\.error|logger\.|FIXME/.test(nextTwo)) {
    return false;
  }

  const ws = getIndent(catchLine);
  lines.splice(
    idx + 1,
    0,
    `${ws}  // FIXME(dev-empty-catch): Replace with proper error handling`,
    `${ws}  console.error('[caught]', ${errVar});`,
  );
  writeLines(file, lines);
  return true;
}

// â”€â”€ Strategy Router â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Returns a fix function for the given issue, or null if no strategy exists.
 * Matching is prefix-based so the dynamic file/line suffixes are handled naturally.
 */
function getStrategy(issue) {
  const { id, file, line: lineNum } = issue;

  // â”€â”€ Architect â€” CRITICAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (id.startsWith("arch-json-parse-")) {
    return () => {
      const ok = insertCommentAbove(
        file,
        lineNum,
        "// FIXME(arch-json-parse): Wrap JSON.parse() in try-catch â€” malformed input will crash service",
      );
      return ok ? `Marked ${file}:${lineNum}` : null;
    };
  }

  if (id.startsWith("arch-interval-leak-")) {
    return () => {
      const ok = addIntervalWarning(file);
      return ok ? `Marked setInterval in ${file}` : null;
    };
  }

  // â”€â”€ Architect â€” IMPORTANT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (id.startsWith("arch-god-object-")) {
    return () =>
      `REPORT: ${file} is too large â€” split into focused modules (manual refactor needed)`;
  }

  if (id.startsWith("arch-unbounded-cache-")) {
    return () => {
      const ok = insertCommentAtTop(
        file,
        "// FIXME(arch-unbounded-cache): Add cache size limit or LRU eviction â€” risk of memory exhaustion",
      );
      return ok ? `Marked cache in ${file}` : null;
    };
  }

  // â”€â”€ Developer â€” CRITICAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (id.startsWith("dev-empty-catch-")) {
    return () => {
      const ok = fixEmptyCatch(file, lineNum);
      return ok ? `Added error logging at ${file}:${lineNum}` : null;
    };
  }

  // â”€â”€ Developer â€” IMPORTANT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (id.startsWith("dev-console-log-")) {
    return () => {
      const ok = insertCommentAbove(
        file,
        lineNum,
        "// FIXME(dev-console-log): Replace with structured logger (logger.info/warn/error)",
      );
      return ok ? `Marked console.log at ${file}:${lineNum}` : null;
    };
  }

  if (id.startsWith("dev-as-any-")) {
    return () =>
      `REPORT: ${file} has excessive 'as any' casts â€” replace with typed interfaces (${issue.description})`;
  }

  // â”€â”€ Security â€” CRITICAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (id.startsWith("sec-hardcoded-secret-")) {
    return () => {
      const ok = insertCommentAbove(
        file,
        lineNum,
        "// FIXME(sec-hardcoded-secret): âš ï¸ SECURITY â€” move credential to .env / secrets manager",
      );
      return ok ? `Marked secret at ${file}:${lineNum}` : null;
    };
  }

  if (id.startsWith("sec-eval-")) {
    return () => {
      const ok = insertCommentAbove(
        file,
        lineNum,
        "// FIXME(sec-eval): âš ï¸ SECURITY â€” eval() is a code injection risk, eliminate dynamic execution",
      );
      return ok ? `Marked eval at ${file}:${lineNum}` : null;
    };
  }

  if (id.startsWith("sec-mime-no-magic-")) {
    return () => {
      const ok = insertCommentAtTop(
        file,
        "// FIXME(sec-mime-no-magic): âš ï¸ SECURITY â€” add magic-byte validation via 'file-type' package",
      );
      return ok ? `Marked MIME bypass in ${file}` : null;
    };
  }

  // â”€â”€ Security â€” IMPORTANT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (id.startsWith("sec-ws-no-auth-")) {
    return () => {
      const ok = insertCommentAtTop(
        file,
        "// FIXME(sec-ws-no-auth): âš ï¸ SECURITY â€” add token validation on WebSocket upgrade",
      );
      return ok ? `Marked WS auth in ${file}` : null;
    };
  }

  if (id.startsWith("sec-sql-injection-")) {
    return () => {
      const ok = insertCommentAbove(
        file,
        lineNum,
        "// FIXME(sec-sql-injection): âš ï¸ SECURITY â€” use parameterized queries, not string interpolation",
      );
      return ok ? `Marked SQL risk at ${file}:${lineNum}` : null;
    };
  }

  if (id.startsWith("sec-path-traversal-")) {
    return () => {
      const ok = insertCommentAbove(
        file,
        lineNum,
        "// FIXME(sec-path-traversal): âš ï¸ SECURITY â€” validate path with PathTraversalValidator before use",
      );
      return ok ? `Marked path traversal at ${file}:${lineNum}` : null;
    };
  }

  if (id.startsWith("sec-unvalidated-cast-")) {
    return () => {
      const ok = insertCommentAbove(
        file,
        lineNum,
        "// FIXME(sec-unvalidated-cast): âš ï¸ SECURITY â€” validate with Zod schema before casting JSON result",
      );
      return ok ? `Marked unvalidated cast at ${file}:${lineNum}` : null;
    };
  }

  // â”€â”€ Tester â€” IMPORTANT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (id.startsWith("test-skipped-")) {
    return () => {
      const ok = insertCommentAbove(
        file,
        lineNum,
        "// FIXME(test-skipped): Unskip this test â€” fix the underlying issue or remove the test",
      );
      return ok ? `Marked skipped test at ${file}:${lineNum}` : null;
    };
  }

  if (id.startsWith("test-no-test-file-")) {
    return () =>
      `REPORT: No test file for ${file} â€” create ${file.replace(/\.ts$/, ".test.ts")} with unit tests`;
  }

  if (id.startsWith("test-flaky-delay-")) {
    return () => {
      const ok = insertCommentAbove(
        file,
        lineNum,
        "// FIXME(test-flaky-delay): Replace setTimeout with vi.useFakeTimers() â€” real delays cause CI flakiness",
      );
      return ok ? `Marked flaky timeout at ${file}:${lineNum}` : null;
    };
  }

  if (id.startsWith("test-no-error-path-")) {
    return () =>
      `REPORT: ${file} has no error path tests â€” add toThrow/rejects/should-fail test cases`;
  }

  // â”€â”€ Nice-to-Have (skip â€” too noisy to add comments for every occurrence) â”€
  if (
    id.startsWith("arch-todo-") ||
    id.startsWith("arch-no-return-type-") ||
    id.startsWith("dev-floating-promise-") ||
    id.startsWith("dev-magic-number-") ||
    id.startsWith("dev-bare-except-") ||
    id.startsWith("test-console-log-") ||
    id.startsWith("test-low-coverage-proxy-")
  ) {
    return () => `SKIP:${issue.description}`;
  }

  return null;
}

// â”€â”€ Apply Fixes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let fixedCount = 0;
let skippedCount = 0;
let unknownCount = 0;

for (const issue of toFix) {
  const strategy = getStrategy(issue);

  if (!strategy) {
    console.log(`  âš ï¸  No strategy for: ${issue.id}`);
    unknownCount++;
    continue;
  }

  try {
    const result = strategy();

    if (typeof result === "string") {
      if (result.startsWith("SKIP:")) {
        // Nice-to-have: silent skip
        skippedCount++;
      } else if (result.startsWith("REPORT:")) {
        console.log(`  ðŸ“‹ ${result.slice(7).trim()}`);
        fixedCount++;
      } else {
        // null = idempotent skip (already fixed), string = success message
        console.log(`  âœ… ${result}`);
        fixedCount++;
      }
    } else if (result === null) {
      // Idempotent skip â€” already marked/fixed
      skippedCount++;
    } else {
      fixedCount++;
    }
  } catch (err) {
    console.error(`  âŒ Failed to fix ${issue.id}: ${err.message}`);
  }
}

console.log(
  `\nâœ… Auto-fixed/marked ${fixedCount} issues` +
    (skippedCount > 0 ? ` (${skippedCount} skipped/already-fixed)` : "") +
    (unknownCount > 0 ? ` (${unknownCount} unknown IDs)` : ""),
);
